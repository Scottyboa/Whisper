<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Transcription Tool</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 40px;
    }
    button {
      font-size: 16px;
      padding: 10px 20px;
      margin: 10px;
      cursor: pointer;
    }
    #recordTimer, #transcribeTimer, #uploadTimer {
      font-size: 18px;
      margin-top: 10px;
    }
    #recordIndicator {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background-color: grey;
      display: inline-block;
      margin-top: 10px;
    }
    #statusMessage {
      font-size: 16px;
      margin-top: 15px;
      font-weight: bold;
      color: #333;
    }
    /* Make the transcription textarea editable */
    #transcription {
      margin-top: 20px;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      width: 80%;
      height: 150px;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
      text-align: left;
    }
    /* New Note Generation UI Styles */
    #noteSection {
      margin-top: 40px;
    }
    #generatedNote {
      margin-top: 20px;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      width: 80%;
      height: 150px;
      max-width: 600px;
      text-align: left;
    }
    select {
      font-size: 16px;
      padding: 5px;
      margin: 10px;
    }
  </style>
</head>
<body>
  <h2>Transcription Tool</h2>
  <div id="recordIndicator"></div>
  <div id="recordTimer">Recording Timer: 0 sec</div>
  <div id="uploadTimer">Upload Timer: 0 sec</div>
  <div id="transcribeTimer">Transcription Timer: 0 sec</div>
  <br>
  <button id="startButton">Start Recording</button>
  <button id="stopButton" disabled>Stop Recording</button>
  <button id="pauseResumeButton" disabled>Pause Recording</button>
  <br>
  <button id="transcribeButton" disabled>Transcribe</button>
  <button id="deleteButton">Delete Recording</button>
  <br>
  <div id="statusMessage">Welcome! Click "Start Recording" to begin.</div>
  <br>
  <h3>Transcription Result:</h3>
  <!-- Now editable: no readonly attribute -->
  <textarea id="transcription"></textarea>
  
  <!-- New Note Generation Section -->
  <div id="noteSection">
    <h3>Generate Note:</h3>
    <select id="noteType">
      <option value="medisinsk_notat">Konsultasjonsnotat</option>
      <option value="legemiddelgjennomgang">Systematisk legemiddelgjennomgang</option>
    </select>
    <button id="generateNoteButton">Generate Note</button>
    <h3>Generated Note:</h3>
    <textarea id="generatedNote" readonly></textarea>
  </div>
  
  <script>
    // Utility function: format time as "0 sec", "1 sec", ... "59 sec", "1 min", "1 min 1 sec", etc.
    function formatTime(ms) {
      const totalSec = Math.floor(ms / 1000);
      if (totalSec < 60) {
        return totalSec + " sec";
      } else {
        const minutes = Math.floor(totalSec / 60);
        const seconds = totalSec % 60;
        return minutes + " min" + (seconds > 0 ? " " + seconds + " sec" : "");
      }
    }
    
    // Retrieve API key from sessionStorage
    const apiKey = sessionStorage.getItem("openai_api_key");
    if (!apiKey) {
      alert("API key is missing. Please re-enter it.");
      window.location.href = "index.html";
    }
    
    // Backend URL and recording variables
    const backendUrl = "https://whisper-online.fly.dev";
    let mediaRecorder;
    let audioChunks = [];
    let sessionId = "";
    let recordingStartTime = 0;
    let recordingTimerInterval;
    let uploadTimerInterval;
    let transcriptionTimerInterval;
    let isPaused = false;
    let pausedTimeAccumulated = 0;
    let pauseStartTime = 0;
    let autoDeleteTimeout;
    let uploadStartTime = 0;
    let mediaStream = null;
    
    function updateStatusMessage(message, color = "#333") {
      const statusMessage = document.getElementById("statusMessage");
      statusMessage.innerText = message;
      statusMessage.style.color = color;
    }
    
    function updateRecordingTimer() {
      let elapsed = Date.now() - recordingStartTime - pausedTimeAccumulated;
      document.getElementById("recordTimer").innerText = "Recording Timer: " + formatTime(elapsed);
    }
    
    function updateUploadTimer() {
      let elapsed = Date.now() - uploadStartTime;
      document.getElementById("uploadTimer").innerText = "Upload Timer: " + formatTime(elapsed);
    }
    
    async function handleStop() {
      clearInterval(recordingTimerInterval);
      updateStatusMessage("Uploading audio... Please wait.", "blue");
    
      const audioBlob = new Blob(audioChunks, { type: 'audio/mp3' });
      const formData = new FormData();
      formData.append("file", audioBlob, "recorded.mp3");
    
      uploadStartTime = Date.now();
      document.getElementById("uploadTimer").innerText = "Upload Timer: 0 sec";
      uploadTimerInterval = setInterval(updateUploadTimer, 1000);
    
      try {
        const response = await fetch(`${backendUrl}/upload`, {
          method: "POST",
          body: formData
        });
        const result = await response.json();
        clearInterval(uploadTimerInterval);
    
        if (result.session_id) {
          sessionId = result.session_id;
          document.getElementById("recordIndicator").style.backgroundColor = "green";
          updateStatusMessage("Audio uploaded! Ready for transcription.", "green");
          document.getElementById("transcribeButton").disabled = false;
    
          clearTimeout(autoDeleteTimeout);
          autoDeleteTimeout = setTimeout(() => { deleteRecording(); }, 300000);
        } else {
          updateStatusMessage("Upload error: " + (result.error || "Unknown error"), "red");
        }
      } catch (error) {
        updateStatusMessage("Error uploading file: " + error, "red");
      }
    
      stopMicrophone();
    }
    
    function stopMicrophone() {
      if (mediaStream) {
        mediaStream.getTracks().forEach(track => track.stop());
        mediaStream = null;
      }
    }
    
    document.getElementById("startButton").addEventListener("click", async () => {
      try {
        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(mediaStream);
        audioChunks = [];
        isPaused = false;
        pausedTimeAccumulated = 0;
        recordingStartTime = Date.now();
        updateRecordingTimer();
        recordingTimerInterval = setInterval(updateRecordingTimer, 1000);
    
        mediaRecorder.ondataavailable = event => {
          if (event.data.size > 0) {
            audioChunks.push(event.data);
          }
        };
        mediaRecorder.onstop = handleStop;
        mediaRecorder.start();
    
        document.getElementById("startButton").disabled = true;
        document.getElementById("stopButton").disabled = false;
        document.getElementById("pauseResumeButton").disabled = false;
        document.getElementById("pauseResumeButton").innerText = "Pause Recording";
        document.getElementById("recordIndicator").style.backgroundColor = "red";
        updateStatusMessage("Recording in progress...");
      } catch (error) {
        updateStatusMessage("Microphone access error: " + error, "red");
      }
    });
    
    document.getElementById("stopButton").addEventListener("click", () => {
      if (mediaRecorder && mediaRecorder.state !== "inactive") {
        mediaRecorder.stop();
        document.getElementById("startButton").disabled = false;
        document.getElementById("stopButton").disabled = true;
        document.getElementById("pauseResumeButton").disabled = true;
      }
    });
    
    document.getElementById("pauseResumeButton").addEventListener("click", () => {
      if (!mediaRecorder) return;
      if (mediaRecorder.state === "recording") {
        mediaRecorder.pause();
        pauseStartTime = Date.now();
        clearInterval(recordingTimerInterval);
        document.getElementById("pauseResumeButton").innerText = "Resume Recording";
        updateStatusMessage("Recording paused", "orange");
      } else if (mediaRecorder.state === "paused") {
        mediaRecorder.resume();
        pausedTimeAccumulated += Date.now() - pauseStartTime;
        recordingTimerInterval = setInterval(updateRecordingTimer, 1000);
        document.getElementById("pauseResumeButton").innerText = "Pause Recording";
        updateStatusMessage("Recording resumed", "green");
      }
    });
    
    document.getElementById("transcribeButton").addEventListener("click", async () => {
      const storedApiKey = sessionStorage.getItem("openai_api_key");
      if (!storedApiKey || !sessionId) {
        updateStatusMessage("API key or recording missing.", "red");
        return;
      }
    
      updateStatusMessage("Transcription in progress...", "blue");
      const transcriptionStart = Date.now();
      transcriptionTimerInterval = setInterval(() => {
        document.getElementById("transcribeTimer").innerText = "Transcription Timer: " + Math.floor((Date.now() - transcriptionStart) / 1000) + " s";
      }, 1000);
    
      try {
        const response = await fetch(`${backendUrl}/transcribe`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ api_key: storedApiKey, session_id: sessionId })
        });
        const result = await response.json();
        clearInterval(transcriptionTimerInterval);
    
        if (result.transcription) {
          updateStatusMessage("Transcription complete!", "green");
          document.getElementById("transcription").innerText = result.transcription;
        } else {
          updateStatusMessage("No transcription available.", "red");
        }
      } catch (error) {
        updateStatusMessage("Transcription error: " + error, "red");
      }
    });
    
    document.getElementById("deleteButton").addEventListener("click", deleteRecording);
    
    // Dummy deleteRecording â€“ implement as needed on your backend
    function deleteRecording() {
      updateStatusMessage("Recording deleted.", "green");
      sessionId = "";
    }
    
    // --- Note Generation Functionality ---
    const medisinskNotatPrompt = `Prompt for ny chatlog:

Denne chatloggen brukes til Ã¥ skrive og strukturere profesjonelle konsultasjonsnotater, epikriser og henvisninger basert pÃ¥ opplysninger fra pasientsamtaler og kliniske vurderinger. Notatene skal vÃ¦re detaljerte, presise og faglig korrekte, med en struktur som gjÃ¸r dem egnet for direkte innliming i pasientjournalen.

Struktur for konsultasjonsnotater:
Bakgrunn (kun hvis relevant)
Aktuelt/anamnese
UndersÃ¸kelse
Vurdering
Plan

Krav til sprÃ¥k og stil:
Formuleres i profesjonell, medisinsk stil med tydelig struktur.
Skal ikke inneholde spesialtegn som âœ”, ðŸ“Œ, âœ…, emojis eller lignende.
UnngÃ¥ repetisjon av standardfraser for Ã¥ variere formuleringer.

Andre viktige fÃ¸ringer:
NÃ¥r det er taleopptak eller transkribert dialog, skal teksten omformes til et strukturert, medisinsk notat der talerne identifiseres korrekt.
Notatene skal vÃ¦re utfyllende for Ã¥ reflektere grundige konsultasjoner, inkludert detaljer om pasientkommunikasjon.
Scott Ã¸nsker at notatene ikke inneholder unÃ¸dvendige forklaringer eller generelle rÃ¥d pÃ¥ slutten, men skal vÃ¦re presise og mÃ¥lrettede.
Henvisninger skal vÃ¦re korte, presise og tydelig oppsummere indikasjon og problemstilling.
Hvis jeg pÃ¥ slutten av diktatet forteller at du skal skrive et "langt og fint notat", betyr det at jeg vil at du skal lage notatet noe lengre med mer utfyllende tekst for Ã¥ kunne fylle krav for Ã¥ bruke "tidstakst". Hvis jeg bare sier "skriv et fint notat" pÃ¥ slutten, trenger du ikke gjÃ¸re dette.`;
    
    const legemiddelgjennomgangPrompt = `Jeg vil at du skal skrive en systematisk legemiddelgjennomgang basert pÃ¥ informasjonen jeg gir deg. FÃ¸lgende struktur skal alltid fÃ¸lges:

Systematisk legemiddelgjennomgang
Indikasjon:
List opp alle pasientens relevante diagnoser basert pÃ¥ informasjonen jeg gir deg.

Vurdering:
Legemiddelgjennomgangen er basert pÃ¥ samtale med pasienten (dersom pasienten er til stede) og gjennomgang av pasientens journal og epikriser.
Skriv at det foreligger ingen interaksjoner eller kontraindikasjoner med mindre jeg spesifikt oppgir noe annet.

Medikamentvurdering:
Jeg kommer til Ã¥ gi deg en liste over pasientens medisiner, inkludert dosering.
GÃ¥ gjennom hver enkelt medisin og skriv kort formÃ¥let med medisinen samt om den er indisert.
Dersom jeg ikke eksplisitt sier at en medisin mangler indikasjon, skal du anta at den er indisert og bÃ¸r viderefÃ¸res.

OppfÃ¸lging:
Avslutt alltid med "OppfÃ¸lging ved neste helsekontroll."

Bruk korrekt medisinsk terminologi og hold teksten profesjonell og presis. Skriv i et format som kan kopieres direkte inn i pasientjournalen uten behov for videre redigering.`;
    
    document.getElementById("generateNoteButton").addEventListener("click", async () => {
      const transcriptionText = document.getElementById("transcription").value.trim();
      if (!transcriptionText) {
        alert("No transcription text available.");
        return;
      }
      
      const noteType = document.getElementById("noteType").value;
      let promptText = "";
      if (noteType === "medisinsk_notat") {
        promptText = medisinskNotatPrompt;
      } else if (noteType === "legemiddelgjennomgang") {
        promptText = legemiddelgjennomgangPrompt;
      }
      
      document.getElementById("generatedNote").value = "Generating note, please wait...";
      
      try {
        const response = await fetch("https://api.openai.com/v1/chat/completions", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": "Bearer " + apiKey
          },
          body: JSON.stringify({
            model: "gpt-4",
            messages: [
              { role: "system", content: promptText },
              { role: "user", content: transcriptionText }
            ],
            temperature: 0.7
          })
        });
        const result = await response.json();
        if (result.choices && result.choices.length > 0) {
          document.getElementById("generatedNote").value = result.choices[0].message.content.trim();
        } else {
          document.getElementById("generatedNote").value = "No note generated.";
        }
      } catch (error) {
        document.getElementById("generatedNote").value = "Error generating note: " + error;
      }
    });
  </script>
</body>
</html>
